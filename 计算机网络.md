# 一 OSI 与 TCP/IP 各层的结构与功能,都有哪些协议 

五层协议的体系结构 

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系 结构，这样既简洁又能将概念阐述清楚。 

![image-20230511113557004](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511113557004.png)

![image-20230511113603002](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511113603002.png)

## 1 应用层 

应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程 （进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网 中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把 应用层交互的数据单元称为报文。 

### 域名系统（DNS） 

 域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务，它作为 可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机 器直接读取的 IP 数串。 

 例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司 的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco 公司的域名是 www.cisco.com 等。 

 DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超 过 253 个字符。 

### 文件传输协议（FTP）和简单文件传输协议（TFTP） 

 FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务 器模式，使用 TCP 数据报，提供交互式访问，双向传输。 

 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服 务器方式，使用 UDP 数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 

### HTTP 协议 

定义：  超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。是用于从  WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。所有的 WWW 文件都必须遵 守这个标准。HTTP 是万维网的数据通信的基础。  状态码： 

 1xx：表示通知信息，如请求收到了或正在进行处理 

 100 Continue：继续，客户端应继续其请求 

 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高 级的协议，例如，切换到 HTTP 的新版本协议 

 2xx：表示成功，如接收或知道了 

 200 OK: 请求成功 

 3xx：表示重定向，如要完成请求还必须采取进一步的行动 

 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包 括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 

 4xx：表示客户的差错，如请求中有错误的语法或不能完成 

 400 Bad Request: 客户端请求的语法错误，服务器无法理解 

 401 Unauthorized: 请求要求用户的身份认证 

 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 

 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人 员可设置 “您所请求的资源无法找到” 的个性页面 

 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 

 5xx：表示服务器的差错，如服务器失效无法完成请求 

 500 Internal Server Error: 服务器内部错误，无法完成请求 

 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延 时的长度可包含在服务器的 Retry-After 头信息中 

 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 

200：请求被正常处理 

 204：请求被受理但没有资源可以返回  

206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行 GET 方法，相应报文中通过 Content-Range 指定范围的资源。

301：永久性重定向 

 302：临时重定向  

303：与 302 状态码有相似功能，只是它希望客户端在请求一个 URI 的时候，能通过 GET 方法重定向到另一个 URI 上 、

 304：发送附带条件的请求时，条件不满足时返回，与重定向无关  

307：临时重定向，与 302 类似，只是强制要求使用 POST 方法 

 400：请求报文语法有误，服务器无法识别  

401：请求需要认证  

403：请求的对应资源禁止被访问  

404：服务器无法找到对应资源  

500：服务器内部错误  

503：服务器正忙 

### WWW 

WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问   

### URL 

URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address） 

## 2 运输层 

###  什么是运输层  

运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程 利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个 运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用 层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

### 运输层主要两种协议：TCP、UDP 

（1）传输控制协议 TCP（Transmisson Control Protocol）  是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。  

（2）用户数据协议 UDP（User Datagram Protocol）  提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。是 OSI（Open System  Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送 服务，其传输的单位是用户数据报。 

### 端口

![image-20230511114134921](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511114134921.png)

### UDP 的主要特点

（1）UDP 是无连接的；  

（2）UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；  

（3）UDP 是面向报文的；  

（4）UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实 时视频会议等）；  

（5）UDP 支持一对一、一对多、多对一和多对多的交互通信；  

（6）UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 

### TCP 的主要特点

（1）TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；  

（2）每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；  

（3）TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；  

（4）TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送 缓存和接收缓存，用来临时存放双方通信的数据； 

 （5）面向字节流。TCP 中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是： 虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的 无结构的字节流。 

## 3 网络层 

###  什么是网络层

 **网络层(network layer)负责为分组交换网上的不同主机提供通信服务。**在发送数据时，网络层把运输层产生 的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。

 这里要注意：不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混。另外，无论是哪一层的数 据单元，都可笼统地用“分组”来表示。网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来 的分株，能通过网络层中的路由器找到目的主机。这里强调指出，网络层中的“网络”二字已经不是我们通常 谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.  互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层 协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做**网际层**或 **IP 层**。 

## 4 数据链路层 

**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这 就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装 程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制 等）。  在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一 个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果 发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需 要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性 传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 

## 5 物理层 

###  什么是物理层 

物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和 物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 

### 物理层上所传送的数据单位 

**比特** 

### 数据传输系统 

源系统（源点、发送器） --> 传输系统 --> 目的系统（接收器、终点） 

### 通道 

 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 

 双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收 

 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 

### 通道复用技术 

 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用 不同带宽资源 

 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同 时间占用同样的频带宽度 

 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 

 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带 通信 

# 二 TCP 三次握手（TCP 连接的建立） 

为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。 

## 漫画图解： 

 图片来源：《图解 HTTP》 

![image-20230511115117879](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511115117879.png)

![image-20230511115123624](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511115123624.png)

![image-20230511115132866](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511115132866.png)

## 1、TCP 建立连接的全过程解释（三次握手）  三次握手简单解释 

 客户端发送带有 SYN 标志的数据包给服务器，说明客户端请求建立链接； 一次握手 

 服务端收到客户端发送的 SYN，并回复 SYN+ACK 标志的数据包给客户端（同意建立连接）；二次握手 

 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；三 次握手 

 服务端收到客户端的 ACK，连接已建立，可以数据传输。 

### 三次握手详细解释 

 TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监 听）状态； 

 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1， 同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号。 

 TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到） 状态。这个报文也不能携带数据，但是同样要消耗一个序号。 

 TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1， 此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据， 但是如果不携带数据则不消耗序号。 

 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。 

## 2、 TCP 为什么要三次握手 

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就 是双方确认自己与对方的发送与接收是否正常，确认过程最少要进行三次通信。

* 第一次握手：客户端什么都不能确认；服务端确认了对方发送正常

* 第二次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己接收正常，对方发 送正常

* 第三次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己发送、接收正常， 对方发送接收正常  所以三次握手就能确认双发收发功能都正常，缺一不可。 

## 3 、为什么 TCP 客户端最后还发送一次确认，而不是两次握手 

一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连 接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了， 由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和 服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错 误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并 且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 

## 4、为什么不进行四次握手呢 

为什么不是四次握手呢？ 因为完全可靠的通信协议是根本不存在的， 通信不可能 100%可靠， 而上面的三次握 手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。 

## 5、第三次握手失败怎么处理 

 按照 TCP 协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到 ACK 确认为止。但实际 上这种做法有可能遭到 SYN 泛洪攻击。所谓的泛洪攻击，是指发送方伪造多个 IP 地址，模拟三次握手的过 程。当服务器返回 ACK 后，攻击方故意不确认，从而使得服务器不断重发 ACK。由于服务器长时间处于半 连接状态，最后消耗过多的 CPU 和内存资源导致死机。 

 **正确处理方法**：服务端发送 RST 报文，进入 CLOSE 状态。这个 RST 数据包的 TCP 首部中，控制位中的 RST  位被设置为 1。这表示连接信息全部被初始化，原有的 TCP 通信不能继续进行。客户端如果还想重新建立 TCP  连接，就必须重新开始第一次握手。 

## 6、为什么要传回 SYN 

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 

## 7、传了 SYN,为啥还要传 ACK 

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发 送方的通道还需要 ACK 信号来进行验证。

![image-20230511115514021](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511115514021.png)

# 三 TCP 四次挥手（TCP 连接的释放） 

![image-20230511115530410](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511115530410.png)

## 1、TCP 四次挥手原理

###   四次挥手简单解释 

 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 

 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 

 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 

 服务端继续发送之前没发完的数据给客户端； 

 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没 收到客户端的回复，过段时间也会自动释放）； 

 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）； 

 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。 

### 四次挥手详细解释 

 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前 面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。 

 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务 端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释 放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。 这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 

 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连 接释放报文（在这之前还需要接受服务器发送的最后的数据）。 

 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服 务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认） 状态，等待客户端的确认。 

 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1， 此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2**∗** ***∗**MSL （最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。 

 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCP 后，就结束了这次的 TCP 连 接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 

## 2、为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？ 

### 答案 1：

  MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。 

 第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角 度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它 没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给 出回应报文，并且会重启 2MSL 计时器。 

 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最 后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。 这样新的连接中不会出现旧连接的请求报文。

###   答案 2： 

 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报 文段，客户端再重传 ACK，并重新计时。 

 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的 所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。 

## 3、为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 

###  答案 1

  因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之 前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器 的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。 

###  答案 2  

建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里 发送给客户端。而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据， 而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文 给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。 

## 4、为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？ （ACK 和 FIN 分开是指第二次和第三次挥手） 

因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端 发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数 据传输，因此连接时可以 ACK 和 SYN 一起发送。 

# 四   TCP 和 UDP 的区别 

## 1、TCP 和 UDP 的区别 

1. TCP 面向连接，UDP 是无连接的；
2.  TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达； UDP 尽最大努力交付，即不保证可靠交付
3.  TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道  
4. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信  
5. TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向 报文的（不会出现黏包问题）  
6. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）
7. TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节 

### 其他回答：  

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供 可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音 QQ 视频 、 直播等等  TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播 服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来 建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统 资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首 部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 

## 2、TCP 黏包问题 

### 原因  

TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以 可能会出现两个数据包黏在一起的情况。

###   解决 

 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个 定长的数值就将它作为一个消息。 

 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头 长度来接收包体。 

 在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文 中也含有 \r\n，则会误判为消息的边界。  

 使用更加复杂的应用层协议。 

# 五 TCP 协议保证数据传输可靠性的方式 

## 1、数据合理分片和排序

###   应用数据被分割成 TCP 认为最适合发送的数据块。 

 UDP：IP 数据报大于 1500 字节,大于 MTU.这个时候发送方 IP 层就需要分片(fragmentation).把数据报分成若 干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于 UDP 的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个 UDP 数据报. 

 TCP 会按 MTU 合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。 

##  2、超时重传：

 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一 个确认，将重发这个报文段。  

## 3、校验和：

 TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何 变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

###   4、TCP 的接收端会丢弃重复的数据。 

###  5、流量控制：

 TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳 的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制 协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 

###  6、拥塞控制：

 当网络拥塞时，减少数据的发送。

###   7、停止等待 ARQ 协议（stop and wait）

 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止 发送，等待对方确认。在收到确认后再发下一个分组。

### 1、超时重传 

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的 分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间 更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组， 但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连 续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这 个分组位置的所有分组都已经正确收到了。 

### 2、停止等待协议 

 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在 收到确认后再发下一个分组。 

 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发 送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间 断的在传送。这种传输方式可以明显提高信道利用率。 

### 3、滑动窗口 

TCP 利用滑动窗口实现流量控制的机制。  发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的 前面部分表示不晕与发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新 的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把 数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要 太快，要让接收方来得及接收。 

### 4、流量控制 

流量控制是为了控制发送方发送速率，保证接收方来得及接收。  接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置 为 0，则发送方不能发送数据。

  **方法** 

 利用可变窗口进行流量控制 

![image-20230511120626390](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511120626390.png)

### 5 拥塞控制 

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫 拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制 所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机， 所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到 端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。  为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。 

**TCP 的拥塞控制采用了四种方法**，即 

 [慢开始]( 慢开始：  慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因 为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由 小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。 ) 

 [拥塞避免](拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.) 

 [快重传](在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失 的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的 或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确 认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工 作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 ) 

 快恢复  

在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。 

![image-20230511120748212](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511120748212.png)

# 六 在浏览器中输入 url 地址——显示主页的过程 

百度喜欢问这个题目， 

## 1 打开一个网页，整个过程会使用哪些协议

| **过程**                                                     | 使用的协议                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 浏览器查找域名的 IP 地址  （DNS 查找过程：浏览器缓存、路由器缓存、DNS 缓存） | **DNS：**获取域名对应 IP                                     |
| 浏览器向 web 服务器发送一个 HTTP 请求  （cookies 会随着请求发送给服务器） | **TCP：**与服务器建立 TCP 链接                               |
| 服务器处理请求  （请求 处理请求&它的参数、cookies、生成一个 HTML 相应） | **IP：**建立 TCP 协议时，需要发送数据，发送数据 在网络层使用 IP 协议 |
| 服务器发回一个 HTML 相应                                     | **OPSF：**IP 数据包在路由器之间，路由器选择使用 OPSF 协议    |
| 浏览器开始显示 HTML                                          | **ARP：**路由器在与服务器通信时，需要将 IP 地址 转换为 MAC 地址，需要使用 ARP 协议 |

# 七 各种协议与 HTTP 协议的关系 

![image-20230511121537096](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511121537096.png)

首先发给 DNS 服务器，进行域名解析，得到 IP 地址后生成针对目标 Web 服务器的 HTTP 请求报文，然后报文由 TCP 协议负责传输，为了方便通信，HTTP 请求报文被分为报文段，然后每个报文段可靠的传输给对方，然后报文 段由 IP 层负责一边中转一遍传送，服务器收到报文段后重组报文段，然后由应用层的 HTTP 协议处理请求的内容， 请求的结果以 同样的方式进行回传。 

# 八、HTTP 常见面试题 

## 1、Http 与 Https 的区别： 

 HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头 

 HTTP 是不安全的，而 HTTPS 是安全的 

 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 

 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层 

 HTTP 无法加密，而 HTTPS 对传输的数据进行加密 

 HTTP 无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书 

## 2、什么是 Http 协议无状态协议？怎么解决 Http 协议无状态协议? 

###  什么是 HTTP 协议无状态协议  

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。也就是说，当客户端 一次 HTTP 请求完成以后，客户端再发送一次 HTTP 请求，HTTP 并不知道当前客户端是一个老用户。 

###  解决无状态协议的方法  

可以使用 Cookie 来解决无状态的问题，Cookie 就相当于一个通行证，第一次访问的时候给客户端发送一个 Cookie，当客户端再次来的时候，拿着 Cookie(通行证)，那么服务器就知道这个是”老用户“。 

## 3、什么是 cookie 和 session 

###  Cookie  

cookie 采用的是客户端的会话状态的一种储存机制。它是服务器在本地机器上存储的小段文本或者是内存中 的一段数据，并随每一个请求发送至同一个服务器。

### Session 

 Session 是一种服务端的信息管理机制，它通过把这些文件信息以文件的形式存放在服务器的硬盘空间上。

### 请求过程：

浏览器或者客户端发出请求的时候，要求服务端会产生一个 session，这时服务端会先检查一下客户端中的 Cookie 是否包含 session_id 或者 Session 的加密信息，并且判断是否过期。那么这个时候如果发现存在没有 过期的 session_id，那么服务端会根据 session_id 检索存储在服务端本地的信息，然后供用户访问。如果不 存在，那么将重新生成一个 Session。

## 4、cookie 和 session 的区别 

###  存在的位置  

cookie 存在于客户端，临时文件夹中；session 存在于服务器的内存中，一个 session 域对象为一个用户浏 览器服务 

###  安全性

  cookie 是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放； session 存放 于服务器的内存中，所以安全性好 

###  网络传输量  

cookie 会传递消息给服务器； session 本身存放于服务器，不会有传送流量 

###  生命周期(以 20 分钟为例) 

 cookie 的生命周期是累计的，从创建时，就开始计时，20 分钟后，cookie 生命周期结束；session 的生命周 期是间隔的，从创建时，开始计时如在 20 分钟，没有访问 session，那么 session 生命周期被销毁。但是，如果 在 20 分钟内（如在第 19 分钟时）访问过 session，那么，将重新计算 session 的生命周期。关机会造成 session 生命周期的结束，但是对 cookie 没有影响 

###  访问范围

cookie 为多个用户浏览器共享； session 为一个用户浏览器独享 

# 5、URI 和 URL 的区别 

###  URI 是统一资源标识符，用来唯一的标识一个资源。 

 Web 上可用的每种资源如 HTML 文档、图像、视频片段、程序等都是一个来 URI 来定位的 

 URI 一般由三部组成：  ① 问资源的命名机制  ② 存放资源的主机名  ③ 资源自身的名称，由路径表示，着重强调于资源 

###  URL 是统一资源定位器，它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。 

 URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上，特别是 著名的 Mosaic。 

 采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL 一般由 三部组成：

*  ① 协议(或称为服务方式)  

* ② 存有该资源的主机 IP 地址(有时也包括端口号) 

* ③ 主机资源的具体地址。如目录和文件名等 

# 6、HTTPS 的工作原理 

 首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥 （RSA 加密）等进行校验； 

 客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA 加密）； 

 消息体产生的后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名； 

 发送给服务端，此时只有服务端（RSA 私钥）能解密。 

 解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。

# 7、一次完整的 HTTP 事务是怎样一个过程

## 当我们在浏览器里输入 www.baidu.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？ 

 以下过程仅是个人的理解：  

域名解析 --> 发起 TCP 的 3 次握手 --> 建立 TCP 连接后发起 http 请求 --> 服务器响应 http 请求，浏览器得 到 html 代码 --> 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等） --> 浏览器对页面 进行渲染呈现给用户 

# 8、常用的 HTTP 方法 

 GET： 用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器 

 POST：用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。 

 PUT： 传输文件，报文主体中包含文件内容，保存到对应 URI 位置。 

 HEAD： 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。 

 DELETE：删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。 

 OPTIONS：查询相应 URI 支持的 HTTP 方法。 

# 9、HTTP 具有的安全性问题 

 使用明文进行通信，内容可能会被窃听； 

 不验证通信方的身份，通信方的身份有可能遭遇伪装； 

 无法证明报文的完整性，报文有可能遭篡改。

# 10、HTTPS 对 HTTP 的改进（HTTPS 如何保证数据传输的安全） 

##  HTTPS 改进说明 

 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信， 也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和 完整性保护（防篡改）。 

##  加密

  HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使 用对称密钥加密进行通信来保证通信过程的效率。  

### （1）对称密钥加密 

 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 

 优点：运算速度快；  

 缺点：无法安全地将密钥传输给通信方。

![image-20230511122357417](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511122357417.png)

### （2）非对称密钥加密  

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方 收到通信内容后使用私有密钥解密。非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 

优点：可以更安全地将公开密钥传输给通信发送方；  

缺点：运算速度慢。 

![image-20230511122435707](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511122435707.png)

##  认证  

通过使用 证书 来对通信方进行认证。  数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。  服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公 开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一 起。  进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字 签名进行验证，如果验证通过，就可以开始通信了。 

![image-20230511122503555](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230511122503555.png)

##  完整性保护 

 SSL 提供报文摘要功能来进行完整性保护。

  HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计 算 MD5 的值，通信接收方是无法意识到发生了篡改。

  HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密 之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 

# 11、HTTPS 协议的组成 

##  请求报文包括三部分: 

 请求行：包含请求方法,URI,HTTP 版本协议 

 请求首部字段 

 请求内容实体 

##  响应报文包含三部分: 

 状态行：包含 HTTP 版本,状态码,状态码原因短语 

 响应首部字段 

 响应内容实体 